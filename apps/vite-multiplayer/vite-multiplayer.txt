This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
public/
  vite.svg
src/
  game/
    configs/
      dom-settings.ts
      game-config.ts
      score-config.ts
    connection/
      types/
        game-messages.ts
        snake-message.ts
      connection-manager.ts
    const.ts
    event-listeners.ts
    rendered.ts
    utils.ts
  services/
    websocket.service.ts
  main.ts
  vite-env.d.ts
.gitignore
index.html
package.json
tsconfig.json
vite-multiplayer-txt
vite.config.ts

================================================================
Files
================================================================

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: src/game/configs/dom-settings.ts
================
import { GameConfig } from "snake-game-engine";
import { gameConfig } from "./game-config";
import { CELL_SIZE } from "../const";

const dom = (initialRoomCode: string) => document.querySelector<HTMLDivElement>('#app')!.innerHTML = `
  <div class="app">
    <div id="gameBoard" class="game-board"></div>
    <div class="score">Score: <span id="scoreValue" class="score-value">0</span></div>
    <div class="controls">
      ${!initialRoomCode ? `
        <div id="roomControls">
          <button id="createRoomBtn">Create Room</button>
        </div>
      ` : ''}
    </div>
    <div id="roomInfo" style="display: none;">
      Room Code: <span id="roomCode"></span>
    </div>
  </div>
`;

const domeElements = {
  gameBoard: document.getElementById('gameBoard') as HTMLDivElement,
  scoreElement: document.getElementById('scoreValue') as HTMLSpanElement,
  roomControls: document.getElementById('roomControls'),
  roomInfo: document.getElementById('roomInfo') as HTMLDivElement,
  roomCodeSpan: document.getElementById('roomCode') as HTMLSpanElement,
  createRoomBtn: document.getElementById('createRoomBtn')
}

export function getDomElements() {

  const gameBoard = domeElements.gameBoard || document.getElementById('gameBoard') as HTMLDivElement;
  const scoreElement = domeElements.scoreElement || document.getElementById('scoreValue') as HTMLSpanElement;
  const roomControls = domeElements.roomControls || document.getElementById('roomControls');
  const roomInfo = domeElements.roomInfo || document.getElementById('roomInfo') as HTMLDivElement;
  const roomCodeSpan = domeElements.roomCodeSpan || document.getElementById('roomCode') as HTMLSpanElement;
  const createRoomBtn = domeElements.createRoomBtn || document.getElementById('createRoomBtn');

  domeElements.gameBoard = gameBoard;
  domeElements.scoreElement = scoreElement;
  domeElements.roomControls = roomControls;
  domeElements.roomInfo = roomInfo;
  domeElements.roomCodeSpan = roomCodeSpan;
  domeElements.createRoomBtn = createRoomBtn;

  return {
    gameBoard,
    scoreElement,
    roomControls,
    roomInfo,
    roomCodeSpan,
    createRoomBtn
  }
}

export const domSettings = (initialRoomCode: string) => {
  console.log('Setting up DOM');
  const app = dom(initialRoomCode);

  const { gameBoard, scoreElement, roomControls, roomInfo, roomCodeSpan, createRoomBtn } = getDomElements();

  const config: GameConfig = gameConfig(scoreElement);

  gameBoard.style.width = `${config.width * CELL_SIZE}px`;
  gameBoard.style.height = `${config.height * CELL_SIZE}px`;

  return {
    app,
    gameBoard,
    scoreElement,
    roomControls,
    roomInfo,
    roomCodeSpan,
    createRoomBtn
  }
}

================
File: src/game/configs/game-config.ts
================
import { NORMAL_SCORE_CONFIG } from "./score-config";
import { GameConfig } from "snake-game-engine";

export function gameConfig(scoreElement: HTMLElement): GameConfig {
  return {
    width: 20,
    height: 20,
    tickRate: 8,
    continuousSpace: true,
    scoreConfig: {
      ...NORMAL_SCORE_CONFIG,
      onScoreUpdate: (score: number) => {
        scoreElement.textContent = score.toString();
      }
    }
  }
}

================
File: src/game/configs/score-config.ts
================
import { ScoreConfig } from "snake-game-engine";

export const EASY_SCORE_CONFIG: ScoreConfig = {
  foodMultiplier: 100,
  movementMultiplier: 0,  // No movement penalty
  useSnakeLength: false
};

export const NORMAL_SCORE_CONFIG: ScoreConfig = {
  foodMultiplier: 100,
  movementMultiplier: -1,
  useSnakeLength: true
};

export const HARD_SCORE_CONFIG: ScoreConfig = {
  foodMultiplier: 50,
  movementMultiplier: -2,
  useSnakeLength: true
};

// Example of custom scoring logic
export const COMBO_SCORE_CONFIG: ScoreConfig = {
  foodMultiplier: 100,
  movementMultiplier: -1,
  useSnakeLength: true,
  calculateScore: (currentScore, points, isFoodCollision, snakeLength) => {
    let multiplier = 1;

    if (isFoodCollision) {
      // Bonus multiplier based on snake length
      multiplier = Math.floor(snakeLength / 5) + 1;
      return currentScore + (points * multiplier * snakeLength);
    }

    // Movement penalty
    return Math.max(0, currentScore - snakeLength);
  }
};

================
File: src/game/connection/types/game-messages.ts
================
import { Vector2D } from "snake-game-engine";

export const GameMessage = {
  CREATE_ROOM: 'create-room',
  ROOM_CREATED: 'room-created',
  JOIN_ROOM: 'join-room',
  ROOM_JOINED: 'room-joined',
  PLAYER_JOINED: 'player-joined',
  PLAYER_LEFT: 'player-left',
  ROOM_FULL: 'room-full',
  GAME_CAN_START: 'game-can-start',
  START_GAME: 'start-game',
  GAME_STATE: 'game-state',
  ERROR: 'error',
  REQUEST_GAME_STATE: 'request-game-state',
  GAME_STATE_UPDATE: 'game-state-update'
} as const;

export type GameMessage = typeof GameMessage[keyof typeof GameMessage];

// Room constants
export const ROOM_CONSTANTS = {
  MAX_PLAYERS: 4,
  MIN_PLAYERS_TO_START: 2
} as const;

// General game message interfaces
export interface RoomCreatedMessage {
  roomId: string;
  playerId: string;
}

export interface JoinRoomMessage {
  roomId: string;
}

export interface PlayerJoinedMessage {
  playerId: string;
  position: Vector2D;
}

export interface GameStateMessage {
  players: { id: string; snake: Vector2D[] }[];
  foodPosition: Vector2D;
}

export interface ErrorMessage {
  code: string;
  message: string;
}

================
File: src/game/connection/types/snake-message.ts
================
import { Vector2D } from "snake-game-engine";

export const SnakeMessage = {
  PLAYER_POSITION_UPDATE: 'player-position-update',
  FOOD_COLLECTED: 'food-collected',
  PLAYER_DIED: 'player-died'
} as const;


export type SnakeMessage = typeof SnakeMessage[keyof typeof SnakeMessage];

export interface PlayerPositionMessage {
  playerId: string;
  positions: Vector2D[];
}

export interface FoodCollectedMessage {
  collectedBy: string;
  newFoodPosition: Vector2D;
}

export interface PlayerDiedMessage {
  playerId: string;
  finalPositions: Vector2D[];
}

================
File: src/game/connection/connection-manager.ts
================
import { GameConfig, MultiplayerSnake, Vector2D } from "snake-game-engine";
import { GameStateMessage, PlayerJoinedMessage, ErrorMessage, RoomCreatedMessage, GameMessage } from "./types/game-messages";
import { PlayerPositionMessage, FoodCollectedMessage, PlayerDiedMessage, SnakeMessage } from "./types/snake-message";
import { WebSocketService } from "../../services/websocket.service";
import { setRoomInPath, setupMultiplayerGame, useGame } from "../utils";
import { getDomElements } from "../configs/dom-settings";

export type GameHandlers = {
  onGameState: (state: GameStateMessage) => void;
  onPlayerJoined: (data: PlayerJoinedMessage) => void;
  onPlayerLeft: (playerId: string) => void;
  onPlayerPosition: (data: PlayerPositionMessage) => void;
  onFoodCollected: (data: FoodCollectedMessage) => void;
  onPlayerDied: (data: PlayerDiedMessage) => void;
  onError: (error: ErrorMessage) => void;
  onGameCanStart: () => void;
  onGameStateRequest: () => GameStateMessage | null;
  onRoomCreated?: (data: RoomCreatedMessage) => void;
  onRoomJoined?: (data: RoomCreatedMessage) => void;
};

export class SnakeConnectionManager {
  private wsService: WebSocketService<SnakeMessage>;
  private roomId?: string;
  private playerId?: string;
  private handlers: GameHandlers = {
    onGameState: () => { },
    onPlayerJoined: () => { },
    onPlayerLeft: () => { },
    onPlayerPosition: () => { },
    onFoodCollected: () => { },
    onPlayerDied: () => { },
    onError: () => { },
    onGameCanStart: () => { },
    onGameStateRequest: () => null,
    onRoomCreated: () => { },
    onRoomJoined: () => { },
  };

  constructor(serverUrl: string) {
    this.wsService = new WebSocketService(serverUrl);
    this.setupMessageHandlers();
  }

  setHandlers(handlers: GameHandlers) {
    this.handlers = handlers;
    this.setupMessageHandlers();
  }

  private setupMessageHandlers() {
    // Game management message handlers
    this.wsService.on(GameMessage.ROOM_CREATED, (data: RoomCreatedMessage) => {
      this.roomId = data.roomId;
      this.playerId = data.playerId;
      this.handlers.onRoomCreated?.(data);
      console.log('Room created, setting IDs:', this.roomId, this.playerId);
    });

    this.wsService.on(GameMessage.ROOM_JOINED, (data: RoomCreatedMessage) => {
      this.roomId = data.roomId;
      this.playerId = data.playerId;
      this.handlers.onRoomJoined?.(data);
      console.log('Room joined, setting IDs:', this.roomId, this.playerId);
    });

    this.wsService.on(GameMessage.REQUEST_GAME_STATE, () => {
      const state = this.handlers.onGameStateRequest();
      if (state) {
        this.wsService.send(GameMessage.GAME_STATE_UPDATE, state);
      }
    });

    this.wsService.on(GameMessage.GAME_STATE, this.handlers.onGameState);
    this.wsService.on(GameMessage.PLAYER_JOINED, this.handlers.onPlayerJoined);
    this.wsService.on(GameMessage.PLAYER_LEFT, this.handlers.onPlayerLeft);
    this.wsService.on(GameMessage.GAME_CAN_START, this.handlers.onGameCanStart);
    this.wsService.on(GameMessage.ERROR, this.handlers.onError);

    // Snake specific message handlers
    this.wsService.on(SnakeMessage.PLAYER_POSITION_UPDATE, this.handlers.onPlayerPosition);
    this.wsService.on(SnakeMessage.FOOD_COLLECTED, this.handlers.onFoodCollected);
    this.wsService.on(SnakeMessage.PLAYER_DIED, this.handlers.onPlayerDied);

    console.log('Registered handlers:', Array.from(this.wsService['messageHandlers'].keys()));
  }

  // Room management methods
  createRoom() {
    console.log('Creating room');
    this.wsService.send(GameMessage.CREATE_ROOM, {});
  }

  joinRoom(roomId: string) {
    this.wsService.send(GameMessage.JOIN_ROOM, { roomId });
  }

  startGame() {
    if (this.roomId) {
      this.wsService.send(GameMessage.START_GAME, { roomId: this.roomId });
    }
  }

  // Gameplay methods
  sendPosition(positions: Vector2D[]) {
    // console.log('sendPosition:', positions);
    if (this.playerId && this.roomId) {
      this.wsService.send(SnakeMessage.PLAYER_POSITION_UPDATE, {
        playerId: this.playerId,
        positions
      });
    }
  }

  notifyFoodCollected(newFoodPosition: Vector2D) {
    if (this.playerId && this.roomId) {
      this.wsService.send(SnakeMessage.FOOD_COLLECTED, {
        collectedBy: this.playerId,
        newFoodPosition
      });
    }
  }

  notifyPlayerDied(finalPositions: Vector2D[]) {
    if (this.playerId && this.roomId) {
      this.wsService.send(SnakeMessage.PLAYER_DIED, {
        playerId: this.playerId,
        finalPositions
      });
    }
  }

  disconnect() {
    this.wsService.disconnect();
  }

  on(messageType: SnakeMessage | GameMessage, handler: (data: any) => void) {
    this.wsService.on(messageType, handler);
  }
}

export function initializeConnectionManager() {
  const connectionManager = new SnakeConnectionManager(
    'ws://localhost:8080',
  );

  return connectionManager;
}

export function setHandlers(connectionManager: SnakeConnectionManager, gameBoard: HTMLElement, config: GameConfig) {
  connectionManager.setHandlers({
    onGameStateRequest: () => {
      console.log('onGameStateRequest');

      const [game] = useGame();
      if (!game) {
        return null;
      }
      return game.getGameState();
    },
    onGameState: (state) => {

      console.log('onGameState:', state);

      const [game] = useGame();
      if (!game) return;

      // Clear existing players first
      state.players.forEach(player => {
        game.removePlayer(player.id);
      });

      // Add players with their current positions
      state.players.forEach(player => {
        const initialPosition = player.snake[0] || game.getRandomStartPosition();
        game.addPlayer(player.id, initialPosition);
        if (player.snake.length > 0) {
          game.updatePlayerPosition(player.id, player.snake);
        }
      });

      if (state.foodPosition) {
        game.updateFoodPosition(state.foodPosition);
      }
    },
    onPlayerJoined: (data) => {
      console.log('Player joined:', data);
      const [game] = useGame();
      if (!game) return;

      // Use provided position or get a random one
      const position = data.position || game.getRandomStartPosition();
      game.addPlayer(data.playerId, position);
    },
    onPlayerLeft: (playerId) => {
      const [game] = useGame();
      game?.removePlayer(playerId);
    },
    onPlayerPosition: (data) => {
      // console.log('Client received position update:', data);
      const [game] = useGame();
      game?.receivePlayerUpdate(data.playerId, data.positions);
    },
    onFoodCollected: (data) => {
      const [game] = useGame();
      game?.updateFoodPosition(data.newFoodPosition);
    },
    onPlayerDied: (data) => {
      const [game] = useGame();
      game?.removePlayer(data.playerId);
    },
    onError: (error) => {
      alert(`Error: ${error.message}`);
    },
    onGameCanStart: () => {
      const [game] = useGame();
      if (game) {
        setTimeout(() => {
          game.start();
        }, 500);
      }
      // Optional: Show a message that game is starting
      const statusDiv = document.createElement('div');
      statusDiv.textContent = 'Game starting...';
      statusDiv.className = 'game-status';
      gameBoard.parentElement?.insertBefore(statusDiv, gameBoard);
      // Remove the message after a short delay
      setTimeout(() => statusDiv.remove(), 1000);
    },
    onRoomCreated: (data) => {
      console.log('onRoomCreated:', data);
      const { roomCodeSpan } = getDomElements();
      setRoomInPath(data.roomId);
      roomCodeSpan.textContent = data.roomId;
      const [, setGame] = useGame(null);
      const newGame = setupMultiplayerGame(data.playerId, gameBoard, config, connectionManager);
      setGame(newGame);
    },
    onRoomJoined: (data) => {
      console.log('onRoomJoined:', data);
      const { roomCodeSpan } = getDomElements();
      roomCodeSpan.textContent = data.roomId;
      const [, setGame] = useGame(null);
      const game = setupMultiplayerGame(data.playerId, gameBoard, config, connectionManager);
      setGame(game);
    }
  });
}

// export function setOnRoomCreated(connectionManager: SnakeConnectionManager, onRoomCreated: (data: RoomCreatedMessage) => void) {
//   connectionManager.setOnRoomCreated(onRoomCreated);
// }


/*
{
      onGameStateRequest: () => {

        const [game] = useGame();
        if (!game) {
          return null;
        }
        return game.getGameState();
      },
      onGameState: (state) => {
        console.log('Game state:', state);

        const [game] = useGame();
        if (!game) return;

        // Clear existing players first
        state.players.forEach(player => {
          game.removePlayer(player.id);
        });

        // Add players with their current positions
        state.players.forEach(player => {
          const initialPosition = player.snake[0] || game.getRandomStartPosition();
          game.addPlayer(player.id, initialPosition);
          if (player.snake.length > 0) {
            game.updatePlayerPosition(player.id, player.snake);
          }
        });

        if (state.foodPosition) {
          game.updateFoodPosition(state.foodPosition);
        }
      },
      onPlayerJoined: (data) => {
        console.log('Player joined:', data);
        const [game] = useGame();
        if (!game) return;

        // Use provided position or get a random one
        const position = data.position || game.getRandomStartPosition();
        game.addPlayer(data.playerId, position);
      },
      onPlayerLeft: (playerId) => {
        const [game] = useGame();
        game?.removePlayer(playerId);
      },
      onPlayerPosition: (data) => {
        console.log('Received player position:', data);
        const [game] = useGame();
        game?.receivePlayerUpdate(data.playerId, data.positions);
      },
      onFoodCollected: (data) => {
        const [game] = useGame();
        game?.updateFoodPosition(data.newFoodPosition);
      },
      onPlayerDied: (data) => {
        const [game] = useGame();
        game?.removePlayer(data.playerId);
      },
      onError: (error) => {
        alert(`Error: ${error.message}`);
      },
      onGameCanStart: () => {
        const [game] = useGame();
        if (game) {
          setTimeout(() => {
            game.start();
          }, 500);
        }
        // Optional: Show a message that game is starting
        const statusDiv = document.createElement('div');
        statusDiv.textContent = 'Game starting...';
        statusDiv.className = 'game-status';
        gameBoard.parentElement?.insertBefore(statusDiv, gameBoard);
        // Remove the message after a short delay
        setTimeout(() => statusDiv.remove(), 1000);
      },
      onRoomCreated: (data) => {
        const { roomCodeSpan } = getDomElements();
        setRoomInPath(data.roomId);
        roomCodeSpan.textContent = data.roomId;
        const [, setGame] = useGame(null);
        const newGame = setupMultiplayerGame(data.playerId, gameBoard, config, manager);
        setGame(newGame);
      }
    }
 */

================
File: src/game/const.ts
================
export const CELL_SIZE = 20;

================
File: src/game/event-listeners.ts
================
import { GameConfig, Vector2D } from "snake-game-engine";

import { MultiplayerSnake } from "snake-game-engine";
import { GameMessage } from "./connection/types/game-messages";
import { setupMultiplayerGame, useGame } from "./utils";
import { getDomElements } from "./configs/dom-settings";
import { initializeConnectionManager, setHandlers, SnakeConnectionManager } from "./connection/connection-manager";
import { setRoomInPath } from "./utils";

function handleKeydown(event: KeyboardEvent) {
  const [game] = useGame();
  if (!game) return;

  const directions: Record<string, Vector2D> = {
    'ArrowUp': { x: 0, y: -1 },
    'ArrowDown': { x: 0, y: 1 },
    'ArrowLeft': { x: -1, y: 0 },
    'ArrowRight': { x: 1, y: 0 }
  };

  const newDirection = directions[event.key];
  if (newDirection) {
    game.setDirection(newDirection);
  }
}

function handleCreateRoomClick(config: GameConfig) {
  const { gameBoard, roomControls, roomInfo } = getDomElements();

  const manager = initializeConnectionManager();
  setHandlers(manager, gameBoard, config);

  setTimeout(() => {
    manager.createRoom();
  }, 1000);
  if (roomControls) {
    roomControls.style.display = 'none';
  }
  else {
    roomInfo.style.display = 'block';
  }
}

export function setupEventListeners(config: GameConfig, connectionManager: SnakeConnectionManager | null) {

  const { createRoomBtn } = getDomElements();

  document.addEventListener('keydown', (event) => handleKeydown(event));
  createRoomBtn?.addEventListener('click', () => handleCreateRoomClick(config));

  // Clean up on page unload
  window.addEventListener('beforeunload', () => {
    connectionManager?.disconnect();
    const [game] = useGame();
    game?.stop();
  });
}

================
File: src/game/rendered.ts
================
import { RenderConfig, Vector2D } from 'snake-game-engine';

export const createDOMRenderer = (
  container: HTMLElement,
  cellSize: number
): RenderConfig<HTMLElement> => {
  const createCell = (position: Vector2D): HTMLElement => {
    const cell = document.createElement('div');
    cell.className = 'game-cell';
    cell.style.width = `${cellSize - 1}px`;
    cell.style.height = `${cellSize - 1}px`;
    cell.style.left = `${position.x * cellSize}px`;
    cell.style.top = `${position.y * cellSize}px`;
    container.appendChild(cell);
    return cell;
  };

  return {
    cellSize,
    snakeRenderer: (position: Vector2D) => {
      const cell = createCell(position);
      cell.classList.add('snake-segment');
      return cell;
    },
    foodRenderer: (position: Vector2D) => {
      const cell = createCell(position);
      cell.classList.add('food');
      return cell;
    },
    clearRenderer: (element?: HTMLElement) => {
      element?.remove();
    }
  };
};

================
File: src/game/utils.ts
================
import { GameConfig, RenderConfig, Vector2D } from "snake-game-engine";
import { MultiplayerSnake } from "snake-game-engine";
import { CELL_SIZE } from "./const";
import { SnakeConnectionManager } from "./connection/connection-manager";
import { createDOMRenderer } from "./rendered";

export function getRoomFromPath(): string | undefined {
  const path = window.location.pathname;
  const match = path.match(/^\/room\/([A-Za-z0-9]+)$/);
  return match ? match[1] : undefined;
}

export function setRoomInPath(roomId: string) {
  console.log('Setting room in path:', roomId);
  const newPath = `/room/${roomId}`;
  window.history.pushState({}, '', newPath);
}

export function handleGameOver(game: MultiplayerSnake<HTMLElement> | null) {
  alert('Game Over!');
  if (game) {
    game.stop();
  }
}

export function handleKeydown(event: KeyboardEvent, game: MultiplayerSnake<HTMLElement> | null) {
  if (!game) return;

  const directions: Record<string, Vector2D> = {
    'ArrowUp': { x: 0, y: -1 },
    'ArrowDown': { x: 0, y: 1 },
    'ArrowLeft': { x: -1, y: 0 },
    'ArrowRight': { x: 1, y: 0 }
  };

  const newDirection = directions[event.key];
  if (newDirection) {
    game.setDirection(newDirection);
  }
}

export function setupMultiplayerGame(playerId: string, gameBoard: HTMLElement, config: GameConfig, connectionManager: SnakeConnectionManager | null) {
  const renderer = createDOMRenderer(gameBoard, CELL_SIZE);

  const game = new MultiplayerSnake(
    playerId,
    config,
    renderer,
    {
      onFoodCollected: (data) => {
        connectionManager?.notifyFoodCollected(data.newFoodPosition);
      },
      onPlayerPositionUpdate: (playerId, positions) => {
        connectionManager?.sendPosition(positions);
      },
      onPlayerDied: (playerId, finalPositions) => {
        connectionManager?.notifyPlayerDied(finalPositions);
      }
    },
    () => handleGameOver(game)
  );

  return game;
}

let arrToReturn: [MultiplayerSnake<HTMLElement> | null, (game: MultiplayerSnake<HTMLElement>) => void] = [null, (game: MultiplayerSnake<HTMLElement>) => {
  arrToReturn[0] = game;
}];

export const useGame = (initialGame?: MultiplayerSnake<HTMLElement> | null) => {
  const [, setGame] = arrToReturn;
  if (initialGame) {
    setGame(initialGame);
  }
  return arrToReturn;
}

================
File: src/services/websocket.service.ts
================
import { GameMessage } from "../game/connection/types/game-messages";
export class WebSocketService<T extends string = string, MessageType = GameMessage | T> {
  private ws: WebSocket;
  private isConnected: boolean = false;

  // Callback handlers for different message types
  private messageHandlers: Map<MessageType, (data: any) => void> = new Map();

  constructor(serverUrl: string) {
    this.ws = new WebSocket(serverUrl);
    this.setupWebSocket();
  }

  private setupWebSocket() {
    console.log('Setting up WebSocket');
    this.ws.onopen = () => {
      this.isConnected = true;
      console.log('Connected to server');
    };

    this.ws.onclose = () => {
      this.isConnected = false;
      console.log('Disconnected from server');
    };

    this.ws.onmessage = (event) => {

      try {
        const message = JSON.parse(event.data);
        const handler = this.messageHandlers.get(message.type);

        if (handler) {
          handler(message.data);
        }
      } catch (error) {
        console.error('Error processing message:', error);
      }
    };

    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }

  // Register handlers for different message types
  on(messageType: MessageType, handler: (data: any) => void) {
    this.messageHandlers.set(messageType, handler);
  }

  // Send a message to the server
  send(type: MessageType, data: any) {
    if (this.isConnected) {
      const message = JSON.stringify({
        type,
        data
      });
      this.ws.send(message);
    }
  }

  // Clean up connection
  disconnect() {
    if (this.isConnected) {
      this.ws.close();
    }
  }
}

================
File: src/main.ts
================
import '@demo/styles/css/styles.css';
import { GameConfig } from 'snake-game-engine';
import { domSettings } from './game/configs/dom-settings';
import { gameConfig } from './game/configs/game-config';
import { initializeConnectionManager, setHandlers, SnakeConnectionManager } from './game/connection/connection-manager';
import { setupEventListeners } from './game/event-listeners';
import { getRoomFromPath } from './game/utils';

const initialRoomCode = getRoomFromPath();
const { gameBoard, scoreElement, roomInfo, roomCodeSpan } = domSettings(initialRoomCode ?? '');
const config: GameConfig = gameConfig(scoreElement);

let connectionManager: SnakeConnectionManager | null = null;

// Auto-join room if code is present in URL
if (initialRoomCode) {
  connectionManager = initializeConnectionManager();
  setHandlers(connectionManager, gameBoard, config);

  setTimeout(() => {
    connectionManager?.joinRoom(initialRoomCode);
  }, 1000);
  roomInfo.style.display = 'block';
  roomCodeSpan.textContent = initialRoomCode;
}

setupEventListeners(config, connectionManager);

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + TS</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "vite-app-multiplayer",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "clean:cache": "rm -rf node_modules/.vite node_modules/.vite-temp",
    "dev:fresh": "pnpm clean:cache && pnpm dev"
  },
  "devDependencies": {
    "@demo/styles": "workspace:*",
    "@demo/typescript-config": "workspace:*",
    "@types/ws": "^8.5.13",
    "typescript": "~5.6.2",
    "vite": "^6.0.5"
  },
  "dependencies": {
    "snake-game-engine": "link:../../snake-game-engine"
  }
}

================
File: tsconfig.json
================
{
  "extends": "@demo/typescript-config/vite.json",
  "compilerOptions": {
    "baseUrl": "."
  },
  "include": ["src"]
}

================
File: vite-multiplayer-txt
================
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
public/
  vite.svg
src/
  game/
    configs/
      dom-settings.ts
      game-config.ts
      score-config.ts
    connection/
      types/
        game-messages.ts
        snake-message.ts
      connection-manager.ts
    const.ts
    event-listeners.ts
    rendered.ts
    utils.ts
  services/
    websocket.service.ts
  main.ts
  vite-env.d.ts
.gitignore
index.html
package.json
tsconfig.json
vite-multiplayer.txt
vite.config.ts

================================================================
Files
================================================================

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: src/game/configs/dom-settings.ts
================
import { GameConfig } from "snake-game-engine";
import { gameConfig } from "./game-config";
import { CELL_SIZE } from "../const";

const dom = (initialRoomCode: string) => document.querySelector<HTMLDivElement>('#app')!.innerHTML = `
  <div class="app">
    <div id="gameBoard" class="game-board"></div>
    <div class="score">Score: <span id="scoreValue" class="score-value">0</span></div>
    <div class="controls">
      ${!initialRoomCode ? `
        <div id="roomControls">
          <button id="createRoomBtn">Create Room</button>
        </div>
      ` : ''}
    </div>
    <div id="roomInfo" style="display: none;">
      Room Code: <span id="roomCode"></span>
    </div>
  </div>
`;

const domeElements = {
  gameBoard: document.getElementById('gameBoard') as HTMLDivElement,
  scoreElement: document.getElementById('scoreValue') as HTMLSpanElement,
  roomControls: document.getElementById('roomControls'),
  roomInfo: document.getElementById('roomInfo') as HTMLDivElement,
  roomCodeSpan: document.getElementById('roomCode') as HTMLSpanElement,
  createRoomBtn: document.getElementById('createRoomBtn')
}

export function getDomElements() {

  const gameBoard = domeElements.gameBoard || document.getElementById('gameBoard') as HTMLDivElement;
  const scoreElement = domeElements.scoreElement || document.getElementById('scoreValue') as HTMLSpanElement;
  const roomControls = domeElements.roomControls || document.getElementById('roomControls');
  const roomInfo = domeElements.roomInfo || document.getElementById('roomInfo') as HTMLDivElement;
  const roomCodeSpan = domeElements.roomCodeSpan || document.getElementById('roomCode') as HTMLSpanElement;
  const createRoomBtn = domeElements.createRoomBtn || document.getElementById('createRoomBtn');

  domeElements.gameBoard = gameBoard;
  domeElements.scoreElement = scoreElement;
  domeElements.roomControls = roomControls;
  domeElements.roomInfo = roomInfo;
  domeElements.roomCodeSpan = roomCodeSpan;
  domeElements.createRoomBtn = createRoomBtn;

  return {
    gameBoard,
    scoreElement,
    roomControls,
    roomInfo,
    roomCodeSpan,
    createRoomBtn
  }
}

export const domSettings = (initialRoomCode: string) => {
  console.log('Setting up DOM');
  const app = dom(initialRoomCode);

  const { gameBoard, scoreElement, roomControls, roomInfo, roomCodeSpan, createRoomBtn } = getDomElements();

  const config: GameConfig = gameConfig(scoreElement);

  gameBoard.style.width = `${config.width * CELL_SIZE}px`;
  gameBoard.style.height = `${config.height * CELL_SIZE}px`;

  return {
    app,
    gameBoard,
    scoreElement,
    roomControls,
    roomInfo,
    roomCodeSpan,
    createRoomBtn
  }
}

================
File: src/game/configs/game-config.ts
================
import { NORMAL_SCORE_CONFIG } from "./score-config";
import { GameConfig } from "snake-game-engine";

export function gameConfig(scoreElement: HTMLElement): GameConfig {
  return {
    width: 20,
    height: 20,
    tickRate: 8,
    continuousSpace: true,
    scoreConfig: {
      ...NORMAL_SCORE_CONFIG,
      onScoreUpdate: (score: number) => {
        scoreElement.textContent = score.toString();
      }
    }
  }
}

================
File: src/game/configs/score-config.ts
================
import { ScoreConfig } from "snake-game-engine";

export const EASY_SCORE_CONFIG: ScoreConfig = {
  foodMultiplier: 100,
  movementMultiplier: 0,  // No movement penalty
  useSnakeLength: false
};

export const NORMAL_SCORE_CONFIG: ScoreConfig = {
  foodMultiplier: 100,
  movementMultiplier: -1,
  useSnakeLength: true
};

export const HARD_SCORE_CONFIG: ScoreConfig = {
  foodMultiplier: 50,
  movementMultiplier: -2,
  useSnakeLength: true
};

// Example of custom scoring logic
export const COMBO_SCORE_CONFIG: ScoreConfig = {
  foodMultiplier: 100,
  movementMultiplier: -1,
  useSnakeLength: true,
  calculateScore: (currentScore, points, isFoodCollision, snakeLength) => {
    let multiplier = 1;

    if (isFoodCollision) {
      // Bonus multiplier based on snake length
      multiplier = Math.floor(snakeLength / 5) + 1;
      return currentScore + (points * multiplier * snakeLength);
    }

    // Movement penalty
    return Math.max(0, currentScore - snakeLength);
  }
};

================
File: src/game/connection/types/game-messages.ts
================
import { Vector2D } from "snake-game-engine";

export const GameMessage = {
  CREATE_ROOM: 'create-room',
  ROOM_CREATED: 'room-created',
  JOIN_ROOM: 'join-room',
  ROOM_JOINED: 'room-joined',
  PLAYER_JOINED: 'player-joined',
  PLAYER_LEFT: 'player-left',
  ROOM_FULL: 'room-full',
  GAME_CAN_START: 'game-can-start',
  START_GAME: 'start-game',
  GAME_STATE: 'game-state',
  ERROR: 'error',
  REQUEST_GAME_STATE: 'request-game-state',
  GAME_STATE_UPDATE: 'game-state-update'
} as const;

export type GameMessage = typeof GameMessage[keyof typeof GameMessage];

// Room constants
export const ROOM_CONSTANTS = {
  MAX_PLAYERS: 4,
  MIN_PLAYERS_TO_START: 2
} as const;

// General game message interfaces
export interface RoomCreatedMessage {
  roomId: string;
  playerId: string;
}

export interface JoinRoomMessage {
  roomId: string;
}

export interface PlayerJoinedMessage {
  playerId: string;
  position: Vector2D;
}

export interface GameStateMessage {
  players: { id: string; snake: Vector2D[] }[];
  foodPosition: Vector2D;
}

export interface ErrorMessage {
  code: string;
  message: string;
}

================
File: src/game/connection/types/snake-message.ts
================
import { Vector2D } from "snake-game-engine";

export const SnakeMessage = {
  PLAYER_POSITION_UPDATE: 'player-position-update',
  FOOD_COLLECTED: 'food-collected',
  PLAYER_DIED: 'player-died'
} as const;


export type SnakeMessage = typeof SnakeMessage[keyof typeof SnakeMessage];

export interface PlayerPositionMessage {
  playerId: string;
  positions: Vector2D[];
}

export interface FoodCollectedMessage {
  collectedBy: string;
  newFoodPosition: Vector2D;
}

export interface PlayerDiedMessage {
  playerId: string;
  finalPositions: Vector2D[];
}

================
File: src/game/connection/connection-manager.ts
================
import { GameConfig, MultiplayerSnake, Vector2D } from "snake-game-engine";
import { GameStateMessage, PlayerJoinedMessage, ErrorMessage, RoomCreatedMessage, GameMessage } from "./types/game-messages";
import { PlayerPositionMessage, FoodCollectedMessage, PlayerDiedMessage, SnakeMessage } from "./types/snake-message";
import { WebSocketService } from "../../services/websocket.service";
import { setRoomInPath, setupMultiplayerGame, useGame } from "../utils";
import { getDomElements } from "../configs/dom-settings";

export type GameHandlers = {
  onGameState: (state: GameStateMessage) => void;
  onPlayerJoined: (data: PlayerJoinedMessage) => void;
  onPlayerLeft: (playerId: string) => void;
  onPlayerPosition: (data: PlayerPositionMessage) => void;
  onFoodCollected: (data: FoodCollectedMessage) => void;
  onPlayerDied: (data: PlayerDiedMessage) => void;
  onError: (error: ErrorMessage) => void;
  onGameCanStart: () => void;
  onGameStateRequest: () => GameStateMessage | null;
  onRoomCreated?: (data: RoomCreatedMessage) => void;
  onRoomJoined?: (data: RoomCreatedMessage) => void;
};

export class SnakeConnectionManager {
  private wsService: WebSocketService<SnakeMessage>;
  private roomId?: string;
  private playerId?: string;
  private handlers: GameHandlers = {
    onGameState: () => { },
    onPlayerJoined: () => { },
    onPlayerLeft: () => { },
    onPlayerPosition: () => { },
    onFoodCollected: () => { },
    onPlayerDied: () => { },
    onError: () => { },
    onGameCanStart: () => { },
    onGameStateRequest: () => null,
    onRoomCreated: () => { },
    onRoomJoined: () => { },
  };

  constructor(serverUrl: string) {
    this.wsService = new WebSocketService(serverUrl);
    this.setupMessageHandlers();
  }

  setHandlers(handlers: GameHandlers) {
    this.handlers = handlers;
    this.setupMessageHandlers();
  }

  private setupMessageHandlers() {
    // Game management message handlers
    this.wsService.on(GameMessage.ROOM_CREATED, (data: RoomCreatedMessage) => {
      this.roomId = data.roomId;
      this.playerId = data.playerId;
      this.handlers.onRoomCreated?.(data);
      console.log('Room created, setting IDs:', this.roomId, this.playerId);
    });

    this.wsService.on(GameMessage.ROOM_JOINED, (data: RoomCreatedMessage) => {
      this.roomId = data.roomId;
      this.playerId = data.playerId;
      this.handlers.onRoomJoined?.(data);
      console.log('Room joined, setting IDs:', this.roomId, this.playerId);
    });

    this.wsService.on(GameMessage.REQUEST_GAME_STATE, () => {
      const state = this.handlers.onGameStateRequest();
      if (state) {
        this.wsService.send(GameMessage.GAME_STATE_UPDATE, state);
      }
    });

    this.wsService.on(GameMessage.GAME_STATE, this.handlers.onGameState);
    this.wsService.on(GameMessage.PLAYER_JOINED, this.handlers.onPlayerJoined);
    this.wsService.on(GameMessage.PLAYER_LEFT, this.handlers.onPlayerLeft);
    this.wsService.on(GameMessage.GAME_CAN_START, this.handlers.onGameCanStart);
    this.wsService.on(GameMessage.ERROR, this.handlers.onError);

    // Snake specific message handlers
    this.wsService.on(SnakeMessage.PLAYER_POSITION_UPDATE, this.handlers.onPlayerPosition);
    this.wsService.on(SnakeMessage.FOOD_COLLECTED, this.handlers.onFoodCollected);
    this.wsService.on(SnakeMessage.PLAYER_DIED, this.handlers.onPlayerDied);

    console.log('Registered handlers:', Array.from(this.wsService['messageHandlers'].keys()));
  }

  // Room management methods
  createRoom() {
    console.log('Creating room');
    this.wsService.send(GameMessage.CREATE_ROOM, {});
  }

  joinRoom(roomId: string) {
    this.wsService.send(GameMessage.JOIN_ROOM, { roomId });
  }

  startGame() {
    if (this.roomId) {
      this.wsService.send(GameMessage.START_GAME, { roomId: this.roomId });
    }
  }

  // Gameplay methods
  sendPosition(positions: Vector2D[]) {
    // console.log('sendPosition:', positions);
    if (this.playerId && this.roomId) {
      this.wsService.send(SnakeMessage.PLAYER_POSITION_UPDATE, {
        playerId: this.playerId,
        positions
      });
    }
  }

  notifyFoodCollected(newFoodPosition: Vector2D) {
    if (this.playerId && this.roomId) {
      this.wsService.send(SnakeMessage.FOOD_COLLECTED, {
        collectedBy: this.playerId,
        newFoodPosition
      });
    }
  }

  notifyPlayerDied(finalPositions: Vector2D[]) {
    if (this.playerId && this.roomId) {
      this.wsService.send(SnakeMessage.PLAYER_DIED, {
        playerId: this.playerId,
        finalPositions
      });
    }
  }

  disconnect() {
    this.wsService.disconnect();
  }

  on(messageType: SnakeMessage | GameMessage, handler: (data: any) => void) {
    this.wsService.on(messageType, handler);
  }
}

export function initializeConnectionManager() {
  const connectionManager = new SnakeConnectionManager(
    'ws://localhost:8080',
  );

  return connectionManager;
}

export function setHandlers(connectionManager: SnakeConnectionManager, gameBoard: HTMLElement, config: GameConfig) {
  connectionManager.setHandlers({
    onGameStateRequest: () => {
      console.log('onGameStateRequest');

      const [game] = useGame();
      if (!game) {
        return null;
      }
      return game.getGameState();
    },
    onGameState: (state) => {

      console.log('onGameState:', state);

      const [game] = useGame();
      if (!game) return;

      // Clear existing players first
      state.players.forEach(player => {
        game.removePlayer(player.id);
      });

      // Add players with their current positions
      state.players.forEach(player => {
        const initialPosition = player.snake[0] || game.getRandomStartPosition();
        game.addPlayer(player.id, initialPosition);
        if (player.snake.length > 0) {
          game.updatePlayerPosition(player.id, player.snake);
        }
      });

      if (state.foodPosition) {
        game.updateFoodPosition(state.foodPosition);
      }
    },
    onPlayerJoined: (data) => {
      console.log('Player joined:', data);
      const [game] = useGame();
      if (!game) return;

      // Use provided position or get a random one
      const position = data.position || game.getRandomStartPosition();
      game.addPlayer(data.playerId, position);
    },
    onPlayerLeft: (playerId) => {
      const [game] = useGame();
      game?.removePlayer(playerId);
    },
    onPlayerPosition: (data) => {
      // console.log('Client received position update:', data);
      const [game] = useGame();
      game?.receivePlayerUpdate(data.playerId, data.positions);
    },
    onFoodCollected: (data) => {
      const [game] = useGame();
      game?.updateFoodPosition(data.newFoodPosition);
    },
    onPlayerDied: (data) => {
      const [game] = useGame();
      game?.removePlayer(data.playerId);
    },
    onError: (error) => {
      alert(`Error: ${error.message}`);
    },
    onGameCanStart: () => {
      const [game] = useGame();
      if (game) {
        setTimeout(() => {
          game.start();
        }, 500);
      }
      // Optional: Show a message that game is starting
      const statusDiv = document.createElement('div');
      statusDiv.textContent = 'Game starting...';
      statusDiv.className = 'game-status';
      gameBoard.parentElement?.insertBefore(statusDiv, gameBoard);
      // Remove the message after a short delay
      setTimeout(() => statusDiv.remove(), 1000);
    },
    onRoomCreated: (data) => {
      console.log('onRoomCreated:', data);
      const { roomCodeSpan } = getDomElements();
      setRoomInPath(data.roomId);
      roomCodeSpan.textContent = data.roomId;
      const [, setGame] = useGame(null);
      const newGame = setupMultiplayerGame(data.playerId, gameBoard, config, connectionManager);
      setGame(newGame);
    },
    onRoomJoined: (data) => {
      console.log('onRoomJoined:', data);
      const { roomCodeSpan } = getDomElements();
      roomCodeSpan.textContent = data.roomId;
      const [, setGame] = useGame(null);
      const game = setupMultiplayerGame(data.playerId, gameBoard, config, connectionManager);
      setGame(game);
    }
  });
}

// export function setOnRoomCreated(connectionManager: SnakeConnectionManager, onRoomCreated: (data: RoomCreatedMessage) => void) {
//   connectionManager.setOnRoomCreated(onRoomCreated);
// }


/*
{
      onGameStateRequest: () => {

        const [game] = useGame();
        if (!game) {
          return null;
        }
        return game.getGameState();
      },
      onGameState: (state) => {
        console.log('Game state:', state);

        const [game] = useGame();
        if (!game) return;

        // Clear existing players first
        state.players.forEach(player => {
          game.removePlayer(player.id);
        });

        // Add players with their current positions
        state.players.forEach(player => {
          const initialPosition = player.snake[0] || game.getRandomStartPosition();
          game.addPlayer(player.id, initialPosition);
          if (player.snake.length > 0) {
            game.updatePlayerPosition(player.id, player.snake);
          }
        });

        if (state.foodPosition) {
          game.updateFoodPosition(state.foodPosition);
        }
      },
      onPlayerJoined: (data) => {
        console.log('Player joined:', data);
        const [game] = useGame();
        if (!game) return;

        // Use provided position or get a random one
        const position = data.position || game.getRandomStartPosition();
        game.addPlayer(data.playerId, position);
      },
      onPlayerLeft: (playerId) => {
        const [game] = useGame();
        game?.removePlayer(playerId);
      },
      onPlayerPosition: (data) => {
        console.log('Received player position:', data);
        const [game] = useGame();
        game?.receivePlayerUpdate(data.playerId, data.positions);
      },
      onFoodCollected: (data) => {
        const [game] = useGame();
        game?.updateFoodPosition(data.newFoodPosition);
      },
      onPlayerDied: (data) => {
        const [game] = useGame();
        game?.removePlayer(data.playerId);
      },
      onError: (error) => {
        alert(`Error: ${error.message}`);
      },
      onGameCanStart: () => {
        const [game] = useGame();
        if (game) {
          setTimeout(() => {
            game.start();
          }, 500);
        }
        // Optional: Show a message that game is starting
        const statusDiv = document.createElement('div');
        statusDiv.textContent = 'Game starting...';
        statusDiv.className = 'game-status';
        gameBoard.parentElement?.insertBefore(statusDiv, gameBoard);
        // Remove the message after a short delay
        setTimeout(() => statusDiv.remove(), 1000);
      },
      onRoomCreated: (data) => {
        const { roomCodeSpan } = getDomElements();
        setRoomInPath(data.roomId);
        roomCodeSpan.textContent = data.roomId;
        const [, setGame] = useGame(null);
        const newGame = setupMultiplayerGame(data.playerId, gameBoard, config, manager);
        setGame(newGame);
      }
    }
 */

================
File: src/game/const.ts
================
export const CELL_SIZE = 20;

================
File: src/game/event-listeners.ts
================
import { GameConfig, Vector2D } from "snake-game-engine";

import { MultiplayerSnake } from "snake-game-engine";
import { GameMessage } from "./connection/types/game-messages";
import { setupMultiplayerGame, useGame } from "./utils";
import { getDomElements } from "./configs/dom-settings";
import { initializeConnectionManager, setHandlers, SnakeConnectionManager } from "./connection/connection-manager";
import { setRoomInPath } from "./utils";

function handleKeydown(event: KeyboardEvent) {
  const [game] = useGame();
  if (!game) return;

  const directions: Record<string, Vector2D> = {
    'ArrowUp': { x: 0, y: -1 },
    'ArrowDown': { x: 0, y: 1 },
    'ArrowLeft': { x: -1, y: 0 },
    'ArrowRight': { x: 1, y: 0 }
  };

  const newDirection = directions[event.key];
  if (newDirection) {
    game.setDirection(newDirection);
  }
}

function handleCreateRoomClick(config: GameConfig) {
  const { gameBoard, roomControls, roomInfo } = getDomElements();

  const manager = initializeConnectionManager();
  setHandlers(manager, gameBoard, config);

  setTimeout(() => {
    manager.createRoom();
  }, 1000);
  if (roomControls) {
    roomControls.style.display = 'none';
  }
  else {
    roomInfo.style.display = 'block';
  }
}

export function setupEventListeners(config: GameConfig, connectionManager: SnakeConnectionManager | null) {

  const { createRoomBtn } = getDomElements();

  document.addEventListener('keydown', (event) => handleKeydown(event));
  createRoomBtn?.addEventListener('click', () => handleCreateRoomClick(config));

  // Clean up on page unload
  window.addEventListener('beforeunload', () => {
    connectionManager?.disconnect();
    const [game] = useGame();
    game?.stop();
  });
}

================
File: src/game/rendered.ts
================
import { RenderConfig, Vector2D } from 'snake-game-engine';

export const createDOMRenderer = (
  container: HTMLElement,
  cellSize: number
): RenderConfig<HTMLElement> => {
  const createCell = (position: Vector2D): HTMLElement => {
    const cell = document.createElement('div');
    cell.className = 'game-cell';
    cell.style.width = `${cellSize - 1}px`;
    cell.style.height = `${cellSize - 1}px`;
    cell.style.left = `${position.x * cellSize}px`;
    cell.style.top = `${position.y * cellSize}px`;
    container.appendChild(cell);
    return cell;
  };

  return {
    cellSize,
    snakeRenderer: (position: Vector2D) => {
      const cell = createCell(position);
      cell.classList.add('snake-segment');
      return cell;
    },
    foodRenderer: (position: Vector2D) => {
      const cell = createCell(position);
      cell.classList.add('food');
      return cell;
    },
    clearRenderer: (element?: HTMLElement) => {
      element?.remove();
    }
  };
};

================
File: src/game/utils.ts
================
import { GameConfig, RenderConfig, Vector2D } from "snake-game-engine";
import { MultiplayerSnake } from "snake-game-engine";
import { CELL_SIZE } from "./const";
import { SnakeConnectionManager } from "./connection/connection-manager";
import { createDOMRenderer } from "./rendered";

export function getRoomFromPath(): string | undefined {
  const path = window.location.pathname;
  const match = path.match(/^\/room\/([A-Za-z0-9]+)$/);
  return match ? match[1] : undefined;
}

export function setRoomInPath(roomId: string) {
  console.log('Setting room in path:', roomId);
  const newPath = `/room/${roomId}`;
  window.history.pushState({}, '', newPath);
}

export function handleGameOver(game: MultiplayerSnake<HTMLElement> | null) {
  alert('Game Over!');
  if (game) {
    game.stop();
  }
}

export function handleKeydown(event: KeyboardEvent, game: MultiplayerSnake<HTMLElement> | null) {
  if (!game) return;

  const directions: Record<string, Vector2D> = {
    'ArrowUp': { x: 0, y: -1 },
    'ArrowDown': { x: 0, y: 1 },
    'ArrowLeft': { x: -1, y: 0 },
    'ArrowRight': { x: 1, y: 0 }
  };

  const newDirection = directions[event.key];
  if (newDirection) {
    game.setDirection(newDirection);
  }
}

export function setupMultiplayerGame(playerId: string, gameBoard: HTMLElement, config: GameConfig, connectionManager: SnakeConnectionManager | null) {
  const renderer = createDOMRenderer(gameBoard, CELL_SIZE);

  const game = new MultiplayerSnake(
    playerId,
    config,
    renderer,
    {
      onFoodCollected: (data) => {
        connectionManager?.notifyFoodCollected(data.newFoodPosition);
      },
      onPlayerPositionUpdate: (playerId, positions) => {
        connectionManager?.sendPosition(positions);
      },
      onPlayerDied: (playerId, finalPositions) => {
        connectionManager?.notifyPlayerDied(finalPositions);
      }
    },
    () => handleGameOver(game)
  );

  return game;
}

let arrToReturn: [MultiplayerSnake<HTMLElement> | null, (game: MultiplayerSnake<HTMLElement>) => void] = [null, (game: MultiplayerSnake<HTMLElement>) => {
  arrToReturn[0] = game;
}];

export const useGame = (initialGame?: MultiplayerSnake<HTMLElement> | null) => {
  const [, setGame] = arrToReturn;
  if (initialGame) {
    setGame(initialGame);
  }
  return arrToReturn;
}

================
File: src/services/websocket.service.ts
================
import { GameMessage } from "../game/connection/types/game-messages";
export class WebSocketService<T extends string = string, MessageType = GameMessage | T> {
  private ws: WebSocket;
  private isConnected: boolean = false;

  // Callback handlers for different message types
  private messageHandlers: Map<MessageType, (data: any) => void> = new Map();

  constructor(serverUrl: string) {
    this.ws = new WebSocket(serverUrl);
    this.setupWebSocket();
  }

  private setupWebSocket() {
    console.log('Setting up WebSocket');
    this.ws.onopen = () => {
      this.isConnected = true;
      console.log('Connected to server');
    };

    this.ws.onclose = () => {
      this.isConnected = false;
      console.log('Disconnected from server');
    };

    this.ws.onmessage = (event) => {

      try {
        const message = JSON.parse(event.data);
        const handler = this.messageHandlers.get(message.type);

        if (handler) {
          handler(message.data);
        }
      } catch (error) {
        console.error('Error processing message:', error);
      }
    };

    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }

  // Register handlers for different message types
  on(messageType: MessageType, handler: (data: any) => void) {
    this.messageHandlers.set(messageType, handler);
  }

  // Send a message to the server
  send(type: MessageType, data: any) {
    if (this.isConnected) {
      const message = JSON.stringify({
        type,
        data
      });
      this.ws.send(message);
    }
  }

  // Clean up connection
  disconnect() {
    if (this.isConnected) {
      this.ws.close();
    }
  }
}

================
File: src/main.ts
================
import '@demo/styles/css/styles.css';
import { GameConfig } from 'snake-game-engine';
import { domSettings } from './game/configs/dom-settings';
import { gameConfig } from './game/configs/game-config';
import { initializeConnectionManager, setHandlers, SnakeConnectionManager } from './game/connection/connection-manager';
import { setupEventListeners } from './game/event-listeners';
import { getRoomFromPath } from './game/utils';

const initialRoomCode = getRoomFromPath();
const { gameBoard, scoreElement, roomInfo, roomCodeSpan } = domSettings(initialRoomCode ?? '');
const config: GameConfig = gameConfig(scoreElement);

let connectionManager: SnakeConnectionManager | null = null;

// Auto-join room if code is present in URL
if (initialRoomCode) {
  connectionManager = initializeConnectionManager();
  setHandlers(connectionManager, gameBoard, config);

  setTimeout(() => {
    connectionManager?.joinRoom(initialRoomCode);
  }, 1000);
  roomInfo.style.display = 'block';
  roomCodeSpan.textContent = initialRoomCode;
}

setupEventListeners(config, connectionManager);

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + TS</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "vite-app-multiplayer",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "clean:cache": "rm -rf node_modules/.vite node_modules/.vite-temp",
    "dev:fresh": "pnpm clean:cache && pnpm dev"
  },
  "devDependencies": {
    "@demo/styles": "workspace:*",
    "@demo/typescript-config": "workspace:*",
    "@types/ws": "^8.5.13",
    "typescript": "~5.6.2",
    "vite": "^6.0.5"
  },
  "dependencies": {
    "snake-game-engine": "link:../../snake-game-engine"
  }
}

================
File: tsconfig.json
================
{
  "extends": "@demo/typescript-config/vite.json",
  "compilerOptions": {
    "baseUrl": "."
  },
  "include": ["src"]
}

================
File: vite-multiplayer.txt
================
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
public/
  vite.svg
src/
  game/
    configs/
      dom-settings.ts
      game-config.ts
      score-config.ts
    connection/
      types/
        game-messages.ts
        snake-message.ts
      connection-manager.ts
    const.ts
    event-listeners.ts
    rendered.ts
    utils.ts
  services/
    websocket.service.ts
  main.ts
  vite-env.d.ts
.gitignore
index.html
package.json
tsconfig.json
vite.config.ts

================================================================
Files
================================================================

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: src/game/configs/dom-settings.ts
================
import { GameConfig } from "snake-game-engine";
import { gameConfig } from "./game-config";
import { CELL_SIZE } from "../const";

const dom = (initialRoomCode: string) => document.querySelector<HTMLDivElement>('#app')!.innerHTML = `
  <div class="app">
    <div id="gameBoard" class="game-board"></div>
    <div class="score">Score: <span id="scoreValue" class="score-value">0</span></div>
    <div class="controls">
      ${!initialRoomCode ? `
        <div id="roomControls">
          <button id="createRoomBtn">Create Room</button>
        </div>
      ` : ''}
    </div>
    <div id="roomInfo" style="display: none;">
      Room Code: <span id="roomCode"></span>
    </div>
  </div>
`;

const domeElements = {
  gameBoard: document.getElementById('gameBoard') as HTMLDivElement,
  scoreElement: document.getElementById('scoreValue') as HTMLSpanElement,
  roomControls: document.getElementById('roomControls'),
  roomInfo: document.getElementById('roomInfo') as HTMLDivElement,
  roomCodeSpan: document.getElementById('roomCode') as HTMLSpanElement,
  createRoomBtn: document.getElementById('createRoomBtn')
}

export function getDomElements() {

  const gameBoard = domeElements.gameBoard || document.getElementById('gameBoard') as HTMLDivElement;
  const scoreElement = domeElements.scoreElement || document.getElementById('scoreValue') as HTMLSpanElement;
  const roomControls = domeElements.roomControls || document.getElementById('roomControls');
  const roomInfo = domeElements.roomInfo || document.getElementById('roomInfo') as HTMLDivElement;
  const roomCodeSpan = domeElements.roomCodeSpan || document.getElementById('roomCode') as HTMLSpanElement;
  const createRoomBtn = domeElements.createRoomBtn || document.getElementById('createRoomBtn');

  domeElements.gameBoard = gameBoard;
  domeElements.scoreElement = scoreElement;
  domeElements.roomControls = roomControls;
  domeElements.roomInfo = roomInfo;
  domeElements.roomCodeSpan = roomCodeSpan;
  domeElements.createRoomBtn = createRoomBtn;

  return {
    gameBoard,
    scoreElement,
    roomControls,
    roomInfo,
    roomCodeSpan,
    createRoomBtn
  }
}

export const domSettings = (initialRoomCode: string) => {
  console.log('Setting up DOM');
  const app = dom(initialRoomCode);

  const { gameBoard, scoreElement, roomControls, roomInfo, roomCodeSpan, createRoomBtn } = getDomElements();

  const config: GameConfig = gameConfig(scoreElement);

  gameBoard.style.width = `${config.width * CELL_SIZE}px`;
  gameBoard.style.height = `${config.height * CELL_SIZE}px`;

  return {
    app,
    gameBoard,
    scoreElement,
    roomControls,
    roomInfo,
    roomCodeSpan,
    createRoomBtn
  }
}

================
File: src/game/configs/game-config.ts
================
import { NORMAL_SCORE_CONFIG } from "./score-config";
import { GameConfig } from "snake-game-engine";

export function gameConfig(scoreElement: HTMLElement): GameConfig {
  return {
    width: 20,
    height: 20,
    tickRate: 8,
    continuousSpace: true,
    scoreConfig: {
      ...NORMAL_SCORE_CONFIG,
      onScoreUpdate: (score: number) => {
        scoreElement.textContent = score.toString();
      }
    }
  }
}

================
File: src/game/configs/score-config.ts
================
import { ScoreConfig } from "snake-game-engine";

export const EASY_SCORE_CONFIG: ScoreConfig = {
  foodMultiplier: 100,
  movementMultiplier: 0,  // No movement penalty
  useSnakeLength: false
};

export const NORMAL_SCORE_CONFIG: ScoreConfig = {
  foodMultiplier: 100,
  movementMultiplier: -1,
  useSnakeLength: true
};

export const HARD_SCORE_CONFIG: ScoreConfig = {
  foodMultiplier: 50,
  movementMultiplier: -2,
  useSnakeLength: true
};

// Example of custom scoring logic
export const COMBO_SCORE_CONFIG: ScoreConfig = {
  foodMultiplier: 100,
  movementMultiplier: -1,
  useSnakeLength: true,
  calculateScore: (currentScore, points, isFoodCollision, snakeLength) => {
    let multiplier = 1;

    if (isFoodCollision) {
      // Bonus multiplier based on snake length
      multiplier = Math.floor(snakeLength / 5) + 1;
      return currentScore + (points * multiplier * snakeLength);
    }

    // Movement penalty
    return Math.max(0, currentScore - snakeLength);
  }
};

================
File: src/game/connection/types/game-messages.ts
================
import { Vector2D } from "snake-game-engine";

export const GameMessage = {
  CREATE_ROOM: 'create-room',
  ROOM_CREATED: 'room-created',
  JOIN_ROOM: 'join-room',
  ROOM_JOINED: 'room-joined',
  PLAYER_JOINED: 'player-joined',
  PLAYER_LEFT: 'player-left',
  ROOM_FULL: 'room-full',
  GAME_CAN_START: 'game-can-start',
  START_GAME: 'start-game',
  GAME_STATE: 'game-state',
  ERROR: 'error',
  REQUEST_GAME_STATE: 'request-game-state',
  GAME_STATE_UPDATE: 'game-state-update'
} as const;

export type GameMessage = typeof GameMessage[keyof typeof GameMessage];

// Room constants
export const ROOM_CONSTANTS = {
  MAX_PLAYERS: 4,
  MIN_PLAYERS_TO_START: 2
} as const;

// General game message interfaces
export interface RoomCreatedMessage {
  roomId: string;
  playerId: string;
}

export interface JoinRoomMessage {
  roomId: string;
}

export interface PlayerJoinedMessage {
  playerId: string;
  position: Vector2D;
}

export interface GameStateMessage {
  players: { id: string; snake: Vector2D[] }[];
  foodPosition: Vector2D;
}

export interface ErrorMessage {
  code: string;
  message: string;
}

================
File: src/game/connection/types/snake-message.ts
================
import { Vector2D } from "snake-game-engine";

export const SnakeMessage = {
  PLAYER_POSITION_UPDATE: 'player-position-update',
  FOOD_COLLECTED: 'food-collected',
  PLAYER_DIED: 'player-died'
} as const;


export type SnakeMessage = typeof SnakeMessage[keyof typeof SnakeMessage];

export interface PlayerPositionMessage {
  playerId: string;
  positions: Vector2D[];
}

export interface FoodCollectedMessage {
  collectedBy: string;
  newFoodPosition: Vector2D;
}

export interface PlayerDiedMessage {
  playerId: string;
  finalPositions: Vector2D[];
}

================
File: src/game/connection/connection-manager.ts
================
import { GameConfig, MultiplayerSnake, Vector2D } from "snake-game-engine";
import { GameStateMessage, PlayerJoinedMessage, ErrorMessage, RoomCreatedMessage, GameMessage } from "./types/game-messages";
import { PlayerPositionMessage, FoodCollectedMessage, PlayerDiedMessage, SnakeMessage } from "./types/snake-message";
import { WebSocketService } from "../../services/websocket.service";
import { setRoomInPath, setupMultiplayerGame, useGame } from "../utils";
import { getDomElements } from "../configs/dom-settings";

export type GameHandlers = {
  onGameState: (state: GameStateMessage) => void;
  onPlayerJoined: (data: PlayerJoinedMessage) => void;
  onPlayerLeft: (playerId: string) => void;
  onPlayerPosition: (data: PlayerPositionMessage) => void;
  onFoodCollected: (data: FoodCollectedMessage) => void;
  onPlayerDied: (data: PlayerDiedMessage) => void;
  onError: (error: ErrorMessage) => void;
  onGameCanStart: () => void;
  onGameStateRequest: () => GameStateMessage | null;
  onRoomCreated?: (data: RoomCreatedMessage) => void;
  onRoomJoined?: (data: RoomCreatedMessage) => void;
};

export class SnakeConnectionManager {
  private wsService: WebSocketService<SnakeMessage>;
  private roomId?: string;
  private playerId?: string;
  private handlers: GameHandlers = {
    onGameState: () => { },
    onPlayerJoined: () => { },
    onPlayerLeft: () => { },
    onPlayerPosition: () => { },
    onFoodCollected: () => { },
    onPlayerDied: () => { },
    onError: () => { },
    onGameCanStart: () => { },
    onGameStateRequest: () => null,
    onRoomCreated: () => { },
    onRoomJoined: () => { },
  };

  constructor(serverUrl: string) {
    this.wsService = new WebSocketService(serverUrl);
    this.setupMessageHandlers();
  }

  setHandlers(handlers: GameHandlers) {
    this.handlers = handlers;
    this.setupMessageHandlers();
  }

  private setupMessageHandlers() {
    // Game management message handlers
    this.wsService.on(GameMessage.ROOM_CREATED, (data: RoomCreatedMessage) => {
      this.roomId = data.roomId;
      this.playerId = data.playerId;
      this.handlers.onRoomCreated?.(data);
      console.log('Room created, setting IDs:', this.roomId, this.playerId);
    });

    this.wsService.on(GameMessage.ROOM_JOINED, (data: RoomCreatedMessage) => {
      this.roomId = data.roomId;
      this.playerId = data.playerId;
      this.handlers.onRoomJoined?.(data);
      console.log('Room joined, setting IDs:', this.roomId, this.playerId);
    });

    this.wsService.on(GameMessage.REQUEST_GAME_STATE, () => {
      const state = this.handlers.onGameStateRequest();
      if (state) {
        this.wsService.send(GameMessage.GAME_STATE_UPDATE, state);
      }
    });

    this.wsService.on(GameMessage.GAME_STATE, this.handlers.onGameState);
    this.wsService.on(GameMessage.PLAYER_JOINED, this.handlers.onPlayerJoined);
    this.wsService.on(GameMessage.PLAYER_LEFT, this.handlers.onPlayerLeft);
    this.wsService.on(GameMessage.GAME_CAN_START, this.handlers.onGameCanStart);
    this.wsService.on(GameMessage.ERROR, this.handlers.onError);

    // Snake specific message handlers
    this.wsService.on(SnakeMessage.PLAYER_POSITION_UPDATE, this.handlers.onPlayerPosition);
    this.wsService.on(SnakeMessage.FOOD_COLLECTED, this.handlers.onFoodCollected);
    this.wsService.on(SnakeMessage.PLAYER_DIED, this.handlers.onPlayerDied);

    console.log('Registered handlers:', Array.from(this.wsService['messageHandlers'].keys()));
  }

  // Room management methods
  createRoom() {
    console.log('Creating room');
    this.wsService.send(GameMessage.CREATE_ROOM, {});
  }

  joinRoom(roomId: string) {
    this.wsService.send(GameMessage.JOIN_ROOM, { roomId });
  }

  startGame() {
    if (this.roomId) {
      this.wsService.send(GameMessage.START_GAME, { roomId: this.roomId });
    }
  }

  // Gameplay methods
  sendPosition(positions: Vector2D[]) {
    console.log('sendPosition:', positions);
    if (this.playerId && this.roomId) {
      this.wsService.send(SnakeMessage.PLAYER_POSITION_UPDATE, {
        playerId: this.playerId,
        positions
      });
    }
  }

  notifyFoodCollected(newFoodPosition: Vector2D) {
    if (this.playerId && this.roomId) {
      this.wsService.send(SnakeMessage.FOOD_COLLECTED, {
        collectedBy: this.playerId,
        newFoodPosition
      });
    }
  }

  notifyPlayerDied(finalPositions: Vector2D[]) {
    if (this.playerId && this.roomId) {
      this.wsService.send(SnakeMessage.PLAYER_DIED, {
        playerId: this.playerId,
        finalPositions
      });
    }
  }

  disconnect() {
    this.wsService.disconnect();
  }

  on(messageType: SnakeMessage | GameMessage, handler: (data: any) => void) {
    this.wsService.on(messageType, handler);
  }
}

export function initializeConnectionManager() {
  const connectionManager = new SnakeConnectionManager(
    'ws://localhost:8080',
  );

  return connectionManager;
}

export function setHandlers(connectionManager: SnakeConnectionManager, gameBoard: HTMLElement, config: GameConfig) {
  connectionManager.setHandlers({
    onGameStateRequest: () => {

      const [game] = useGame();
      if (!game) {
        return null;
      }
      return game.getGameState();
    },
    onGameState: (state) => {

      const [game] = useGame();
      if (!game) return;

      // Clear existing players first
      state.players.forEach(player => {
        game.removePlayer(player.id);
      });

      // Add players with their current positions
      state.players.forEach(player => {
        const initialPosition = player.snake[0] || game.getRandomStartPosition();
        game.addPlayer(player.id, initialPosition);
        if (player.snake.length > 0) {
          game.updatePlayerPosition(player.id, player.snake);
        }
      });

      if (state.foodPosition) {
        game.updateFoodPosition(state.foodPosition);
      }
    },
    onPlayerJoined: (data) => {
      console.log('Player joined:', data);
      const [game] = useGame();
      if (!game) return;

      // Use provided position or get a random one
      const position = data.position || game.getRandomStartPosition();
      game.addPlayer(data.playerId, position);
    },
    onPlayerLeft: (playerId) => {
      const [game] = useGame();
      game?.removePlayer(playerId);
    },
    onPlayerPosition: (data) => {
      const [game] = useGame();
      game?.receivePlayerUpdate(data.playerId, data.positions);
    },
    onFoodCollected: (data) => {
      const [game] = useGame();
      game?.updateFoodPosition(data.newFoodPosition);
    },
    onPlayerDied: (data) => {
      const [game] = useGame();
      game?.removePlayer(data.playerId);
    },
    onError: (error) => {
      alert(`Error: ${error.message}`);
    },
    onGameCanStart: () => {
      const [game] = useGame();
      if (game) {
        setTimeout(() => {
          game.start();
        }, 500);
      }
      // Optional: Show a message that game is starting
      const statusDiv = document.createElement('div');
      statusDiv.textContent = 'Game starting...';
      statusDiv.className = 'game-status';
      gameBoard.parentElement?.insertBefore(statusDiv, gameBoard);
      // Remove the message after a short delay
      setTimeout(() => statusDiv.remove(), 1000);
    },
    onRoomCreated: (data) => {
      console.log('onRoomCreated:', data);
      const { roomCodeSpan } = getDomElements();
      setRoomInPath(data.roomId);
      roomCodeSpan.textContent = data.roomId;
      const [, setGame] = useGame(null);
      const newGame = setupMultiplayerGame(data.playerId, gameBoard, config, connectionManager);
      setGame(newGame);
    },
    onRoomJoined: (data) => {
      console.log('onRoomJoined:', data);
      const { roomCodeSpan } = getDomElements();
      roomCodeSpan.textContent = data.roomId;
      const [, setGame] = useGame(null);
      const game = setupMultiplayerGame(data.playerId, gameBoard, config, connectionManager);
      setGame(game);
    }
  });
}

// export function setOnRoomCreated(connectionManager: SnakeConnectionManager, onRoomCreated: (data: RoomCreatedMessage) => void) {
//   connectionManager.setOnRoomCreated(onRoomCreated);
// }


/*
{
      onGameStateRequest: () => {

        const [game] = useGame();
        if (!game) {
          return null;
        }
        return game.getGameState();
      },
      onGameState: (state) => {
        console.log('Game state:', state);

        const [game] = useGame();
        if (!game) return;

        // Clear existing players first
        state.players.forEach(player => {
          game.removePlayer(player.id);
        });

        // Add players with their current positions
        state.players.forEach(player => {
          const initialPosition = player.snake[0] || game.getRandomStartPosition();
          game.addPlayer(player.id, initialPosition);
          if (player.snake.length > 0) {
            game.updatePlayerPosition(player.id, player.snake);
          }
        });

        if (state.foodPosition) {
          game.updateFoodPosition(state.foodPosition);
        }
      },
      onPlayerJoined: (data) => {
        console.log('Player joined:', data);
        const [game] = useGame();
        if (!game) return;

        // Use provided position or get a random one
        const position = data.position || game.getRandomStartPosition();
        game.addPlayer(data.playerId, position);
      },
      onPlayerLeft: (playerId) => {
        const [game] = useGame();
        game?.removePlayer(playerId);
      },
      onPlayerPosition: (data) => {
        console.log('Received player position:', data);
        const [game] = useGame();
        game?.receivePlayerUpdate(data.playerId, data.positions);
      },
      onFoodCollected: (data) => {
        const [game] = useGame();
        game?.updateFoodPosition(data.newFoodPosition);
      },
      onPlayerDied: (data) => {
        const [game] = useGame();
        game?.removePlayer(data.playerId);
      },
      onError: (error) => {
        alert(`Error: ${error.message}`);
      },
      onGameCanStart: () => {
        const [game] = useGame();
        if (game) {
          setTimeout(() => {
            game.start();
          }, 500);
        }
        // Optional: Show a message that game is starting
        const statusDiv = document.createElement('div');
        statusDiv.textContent = 'Game starting...';
        statusDiv.className = 'game-status';
        gameBoard.parentElement?.insertBefore(statusDiv, gameBoard);
        // Remove the message after a short delay
        setTimeout(() => statusDiv.remove(), 1000);
      },
      onRoomCreated: (data) => {
        const { roomCodeSpan } = getDomElements();
        setRoomInPath(data.roomId);
        roomCodeSpan.textContent = data.roomId;
        const [, setGame] = useGame(null);
        const newGame = setupMultiplayerGame(data.playerId, gameBoard, config, manager);
        setGame(newGame);
      }
    }
 */

================
File: src/game/const.ts
================
export const CELL_SIZE = 20;

================
File: src/game/event-listeners.ts
================
import { GameConfig, Vector2D } from "snake-game-engine";

import { MultiplayerSnake } from "snake-game-engine";
import { GameMessage } from "./connection/types/game-messages";
import { setupMultiplayerGame, useGame } from "./utils";
import { getDomElements } from "./configs/dom-settings";
import { initializeConnectionManager, setHandlers, SnakeConnectionManager } from "./connection/connection-manager";
import { setRoomInPath } from "./utils";

function handleKeydown(event: KeyboardEvent) {
  const [game] = useGame();
  if (!game) return;

  const directions: Record<string, Vector2D> = {
    'ArrowUp': { x: 0, y: -1 },
    'ArrowDown': { x: 0, y: 1 },
    'ArrowLeft': { x: -1, y: 0 },
    'ArrowRight': { x: 1, y: 0 }
  };

  const newDirection = directions[event.key];
  if (newDirection) {
    game.setDirection(newDirection);
  }
}

function handleCreateRoomClick(config: GameConfig) {
  const { gameBoard, roomControls, roomInfo } = getDomElements();

  const manager = initializeConnectionManager();
  setHandlers(manager, gameBoard, config);

  setTimeout(() => {
    manager.createRoom();
  }, 1000);
  if (roomControls) {
    roomControls.style.display = 'none';
  }
  else {
    roomInfo.style.display = 'block';
  }
}

export function setupEventListeners(config: GameConfig, connectionManager: SnakeConnectionManager | null) {

  const { createRoomBtn } = getDomElements();

  document.addEventListener('keydown', (event) => handleKeydown(event));
  createRoomBtn?.addEventListener('click', () => handleCreateRoomClick(config));

  // Clean up on page unload
  window.addEventListener('beforeunload', () => {
    connectionManager?.disconnect();
    const [game] = useGame();
    game?.stop();
  });
}

================
File: src/game/rendered.ts
================
import { RenderConfig, Vector2D } from 'snake-game-engine';

export const createDOMRenderer = (
  container: HTMLElement,
  cellSize: number
): RenderConfig<HTMLElement> => {
  const createCell = (position: Vector2D): HTMLElement => {
    const cell = document.createElement('div');
    cell.className = 'game-cell';
    cell.style.width = `${cellSize - 1}px`;
    cell.style.height = `${cellSize - 1}px`;
    cell.style.left = `${position.x * cellSize}px`;
    cell.style.top = `${position.y * cellSize}px`;
    container.appendChild(cell);
    return cell;
  };

  return {
    cellSize,
    snakeRenderer: (position: Vector2D) => {
      const cell = createCell(position);
      cell.classList.add('snake-segment');
      return cell;
    },
    foodRenderer: (position: Vector2D) => {
      const cell = createCell(position);
      cell.classList.add('food');
      return cell;
    },
    clearRenderer: (element?: HTMLElement) => {
      element?.remove();
    }
  };
};

================
File: src/game/utils.ts
================
import { GameConfig, RenderConfig, Vector2D } from "snake-game-engine";
import { MultiplayerSnake } from "snake-game-engine";
import { CELL_SIZE } from "./const";
import { SnakeConnectionManager } from "./connection/connection-manager";
import { createDOMRenderer } from "./rendered";

export function getRoomFromPath(): string | undefined {
  const path = window.location.pathname;
  const match = path.match(/^\/room\/([A-Za-z0-9]+)$/);
  return match ? match[1] : undefined;
}

export function setRoomInPath(roomId: string) {
  console.log('Setting room in path:', roomId);
  const newPath = `/room/${roomId}`;
  window.history.pushState({}, '', newPath);
}

export function handleGameOver(game: MultiplayerSnake<HTMLElement> | null) {
  alert('Game Over!');
  if (game) {
    game.stop();
  }
}

export function handleKeydown(event: KeyboardEvent, game: MultiplayerSnake<HTMLElement> | null) {
  if (!game) return;

  const directions: Record<string, Vector2D> = {
    'ArrowUp': { x: 0, y: -1 },
    'ArrowDown': { x: 0, y: 1 },
    'ArrowLeft': { x: -1, y: 0 },
    'ArrowRight': { x: 1, y: 0 }
  };

  const newDirection = directions[event.key];
  if (newDirection) {
    game.setDirection(newDirection);
  }
}

export function setupMultiplayerGame(playerId: string, gameBoard: HTMLElement, config: GameConfig, connectionManager: SnakeConnectionManager | null) {
  const renderer = createDOMRenderer(gameBoard, CELL_SIZE);

  const game = new MultiplayerSnake(
    playerId,
    config,
    renderer,
    {
      onFoodCollected: (data) => {
        connectionManager?.notifyFoodCollected(data.newFoodPosition);
      },
      onPlayerPositionUpdate: (playerId, positions) => {
        connectionManager?.sendPosition(positions);
      },
      onPlayerDied: (playerId, finalPositions) => {
        connectionManager?.notifyPlayerDied(finalPositions);
      }
    },
    () => handleGameOver(game)
  );

  return game;
}

let arrToReturn: [MultiplayerSnake<HTMLElement> | null, (game: MultiplayerSnake<HTMLElement>) => void] = [null, (game: MultiplayerSnake<HTMLElement>) => {
  arrToReturn[0] = game;
}];

export const useGame = (initialGame?: MultiplayerSnake<HTMLElement> | null) => {
  const [, setGame] = arrToReturn;
  if (initialGame) {
    setGame(initialGame);
  }
  return arrToReturn;
}

================
File: src/services/websocket.service.ts
================
import { GameMessage } from "../game/connection/types/game-messages";
export class WebSocketService<T extends string = string, MessageType = GameMessage | T> {
  private ws: WebSocket;
  private isConnected: boolean = false;

  // Callback handlers for different message types
  private messageHandlers: Map<MessageType, (data: any) => void> = new Map();

  constructor(serverUrl: string) {
    this.ws = new WebSocket(serverUrl);
    this.setupWebSocket();
  }

  private setupWebSocket() {
    console.log('Setting up WebSocket');
    this.ws.onopen = () => {
      this.isConnected = true;
      console.log('Connected to server');
    };

    this.ws.onclose = () => {
      this.isConnected = false;
      console.log('Disconnected from server');
    };

    this.ws.onmessage = (event) => {

      try {
        const message = JSON.parse(event.data);
        const handler = this.messageHandlers.get(message.type);

        if (handler) {
          handler(message.data);
        }
      } catch (error) {
        console.error('Error processing message:', error);
      }
    };

    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }

  // Register handlers for different message types
  on(messageType: MessageType, handler: (data: any) => void) {
    this.messageHandlers.set(messageType, handler);
  }

  // Send a message to the server
  send(type: MessageType, data: any) {
    if (this.isConnected) {
      const message = JSON.stringify({
        type,
        data
      });
      this.ws.send(message);
    }
  }

  // Clean up connection
  disconnect() {
    if (this.isConnected) {
      this.ws.close();
    }
  }
}

================
File: src/main.ts
================
import '@demo/styles/css/styles.css';
import { GameConfig } from 'snake-game-engine';
import { domSettings } from './game/configs/dom-settings';
import { gameConfig } from './game/configs/game-config';
import { initializeConnectionManager, setHandlers, SnakeConnectionManager } from './game/connection/connection-manager';
import { setupEventListeners } from './game/event-listeners';
import { getRoomFromPath } from './game/utils';

const initialRoomCode = getRoomFromPath();
const { gameBoard, scoreElement, roomInfo, roomCodeSpan } = domSettings(initialRoomCode ?? '');
const config: GameConfig = gameConfig(scoreElement);

let connectionManager: SnakeConnectionManager | null = null;

// Auto-join room if code is present in URL
if (initialRoomCode) {
  connectionManager = initializeConnectionManager();
  setHandlers(connectionManager, gameBoard, config);

  setTimeout(() => {
    connectionManager?.joinRoom(initialRoomCode);
  }, 1000);
  roomInfo.style.display = 'block';
  roomCodeSpan.textContent = initialRoomCode;
}

setupEventListeners(config, connectionManager);

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + TS</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "vite-app-multiplayer",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "clean:cache": "rm -rf node_modules/.vite node_modules/.vite-temp",
    "dev:fresh": "pnpm clean:cache && pnpm dev"
  },
  "devDependencies": {
    "@demo/styles": "workspace:*",
    "@demo/typescript-config": "workspace:*",
    "@types/ws": "^8.5.13",
    "typescript": "~5.6.2",
    "vite": "^6.0.5"
  },
  "dependencies": {
    "snake-game-engine": "link:../../snake-game-engine"
  }
}

================
File: tsconfig.json
================
{
  "extends": "@demo/typescript-config/vite.json",
  "compilerOptions": {
    "baseUrl": "."
  },
  "include": ["src"]
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'

export default defineConfig({
})



================================================================
End of Codebase
================================================================

================
File: vite.config.ts
================
import { defineConfig } from 'vite'

export default defineConfig({
})



================================================================
End of Codebase
================================================================

================
File: vite.config.ts
================
import { defineConfig } from 'vite'

export default defineConfig({
})



================================================================
End of Codebase
================================================================
